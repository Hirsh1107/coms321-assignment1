//COMS321 Programming Assignment 1
//Team member 1: Drew Hirsh - ahirsh@iastate.edu
//Team member 2: Tim Kuehn - timkuehn@iastate.edu

B main

//X19 a[]
//X20 N
main:

ADDI X19, XZR, #0 //a[]
ADDI X20, XZR, #5 //N = 5 

ADDI X0, X19, #0 //a[]
ADDI X1, X20, #0 // N = N (wow big change!)

BL fill //a[] = X0 && N = X1

ADDI X0, X19, #0 //a[]
ADDI X1, X20, #0 // N = N (wow big change!)
PRNT X0
PRNT X1
BL cycle_sort
PRNL
PRNL 
PRNL
//X0 still set from fill
ADDI X1, XZR, #0 //X1 = 0
SUBI X2, X20, #1 //X2 = N-1
ADDI X3, XZR, #0 //X3 = 0

BL binary_search //binary_search(a, 0, N - 1, 0);



ADDI X0, X19, #0 //a[]
ADDI X1, XZR, #0
SUBI X2, X20, #1 //N-1
SUBI X3, X2, #0 //N-1

BL binary_search //binary_search(a, 0, N - 1, n-1);

ADDI X0, X19, #0 //a[]
ADDI X1, XZR, #0
SUBI X2, X20, #1 //N-1
LSR X3, X20, #1 //N/2

BL binary_search //binary_search(a, 0, N - 1, n/2);


ADDI X0, X19, #0 //a[]
ADDI X1, XZR, #0
SUBI X2, X20, #1 //N-1
ADDI X3, X20, #0 //N

BL binary_search //binary_search(a, 0, N - 1, N);


B end


//X0 a[]
//X1 n
//X2 start
//X3 index
//X4 value
complete_cycle:
SUBI SP, SP, #48
STUR LR, [SP, #0] //saving LR to stack
STUR X19, [SP, #8] //save X19 to stack before overwrite
STUR X20, [SP, #16]
STUR X21, [SP, #24]
STUR X22, [SP, #32]
STUR X23, [SP, #40] //save X23 to stack before overwrite

ADDI X19, X0, #0 //a[]
ADDI X20, X1, #0 //n
ADDI X21, X2, #0 //start
ADDI X22, X3, #0 //index
ADDI X23, X4, #0 //value



complete_loop:

SUBS X9, X22, X21         //if index - start end

CBZ X9, exit_complete_cycle    //X3 = value

ADDI X0, X19, #0 //save a[] to saved register
ADDI X1, X20, #0 //save n to saved register
ADDI X2, X21, #0  //save index to saved register
ADDI X3, X23, #0 //X3 = value for call

BL find_index
ADDI X22, X0, #0 //index update

ADDI X0, X19, #0 //param update for call
ADDI X1, X22, #0 //param update for call
ADDI X2, X23, #0 //param update for call

BL skip_duplicates
ADDI X22, X0, #0 //update index

//REPLACES SWAP CALL
LSL X10, X22, #3 //index offset
ADD X10, X19, X10 //X10 = &a[index]
ADD X11, X23, XZR //X11 = value
LDUR X23, [X10, #0] //value = a[index]
STUR X11, [X10, #0] //Stores value to array


B complete_loop
exit_complete_cycle:

LDUR X23, [SP, #40] //reset all stack variables
LDUR X22, [SP, #32]
LDUR X21, [SP, #24]
LDUR X20, [SP, #16]
LDUR X19, [SP, #8]
LDUR LR, [SP, #0] //reset all stack variables
ADDI SP, SP, #48 //deallocate stack space

BR LR


//X0 a[]
//X1 n
cycle_sort:
SUBI SP, SP, #48
STUR LR, [SP, #0] //saving LR to stack
STUR X19, [SP, #8] //save X19 to stack before overwrite
STUR X20, [SP, #16] //n
STUR X21, [SP, #24] //cstart
STUR X22, [SP, #32] //val
STUR X23, [SP, #40] //idx

ADDI X19, X0, #0 //a[]
ADDI X20, X1, #0 //n
ADDI X21, XZR, #0 //int cstart;
//X22 val gets set in for loop
//X23 idx

cycle_sort_loop:

SUBI X10, X20, #1 //n-1
SUBS XZR, X21, X10 //for cstart < n-1
B.GE exit_cycle_sort

PRNT X9

LSL X10, X21, #3 //X10 = 8*cstart
ADD X11, X10, X19 //X11 = &a[cstart]
LDUR X22, [X11, #0] //val = a[cstart]

ADDI X0, X19, #0 //X0 = a[] for find_index
ADDI X1, X20, #0 //X1 = n for find_index
ADDI X2, X21, #0 //X2 = cstart for find_index
ADDI X3, X22, #0 //X3 = val for find_index

PRNT X3
PRNT X2
BL find_index

ADDI X23, X0, #0 //IDX = find_index

SUB X9, X23, X21 //X9 = idx - cstart
PRNT X9

CBZ X9, continue
PRNT X13
ADDI X0, X19, #0 //X3 = a[] for skip duplicates
ADDI X1, X23, #0 //X3 = idx for skip duplicates
ADDI X2, X22, #0 //X3 = val for skip duplicates

PRNT X14
BL skip_duplicates
ADDI X23, X0, #0 //load idx from skip_duplicates
PRNT X15
//swap
LSL X9, X23, #3 //X9 = 8*idx
ADD X10, X9, X19 //X10 = &a[idx]
ADDI X11, X22, #0 //X11 = val
LDUR X22, [X10, #0] //val = a[idx]
STUR X11, [X10, #0]

//Memory control for complete_cycle

ADDI X0, X19, #0 //X0 = a[] for complete_cycle
ADDI X1, X20, #0 //X1 = n for complete_cycle
ADDI X2, X21, #0 //X2 = cstart for complete_cycle
ADDI X3, X23, #0 //X3 = idx for complete_cycle
ADDI X4, X22, #0 //X4 = val for complete_cycle

PRNT X16
BL complete_cycle

continue:
ADDI X21, X21, #1 //cstart++
PRNT X21
B cycle_sort_loop

exit_cycle_sort:


LDUR X23, [SP, #40] //idx
LDUR X22, [SP, #32] //val
LDUR X21, [SP, #24] //cstart
LDUR X20, [SP, #16] //n
LDUR X19, [SP, #8] //save X19 to stack before overwrite
LDUR LR, [SP, #0] //saving LR to stack

ADDI SP, SP, #48
BR LR





//X0 *a
//X1 start
//X2 end
//X3 value
binary_search:
SUBS XZR, X2, X1                //X9 = END - START
B.LT return_negative_one        // END < START return 1 
ADD X9, X1, X2                 //X10 = START + END
LSR X9, X9, #1                 //INDEX = (START+END)/2 

LSL X10, X9, #3                 //X10 = 8*index
ADD X10, X10, X0                //X10 = &a[index]
LDUR X10, [X10, #0]             //X11 = a[index]
SUBS X11, X10, X3               //X11 = a[index] - value
CBZ X11, return_index           //if a[index]==value exit return index

SUBI SP, SP, #8
STUR LR, [SP, #0]
B.GT recursive_call             //binary_search(a, start, index -1, value)
ADDI X1, X9, #1                 //start = index +1
BL binary_search
LDUR LR, [SP, #0]
ADDI SP, SP, #8
BR LR

return_negative_one:
ADDI X0, XZR, #-1               //returns -1
BR LR

return_index:
PRNT x1
PRNT X2
ADD X0, XZR, X9
BR LR

recursive_call:
SUBI X2, X9, #1                 //end = index - 1
BL binary_search                //binary_search(a, index+1, end, value)
LDUR LR, [SP, #0]
ADDI SP, SP, #8
BR LR



swap:
LDUR X9, [X0, #0]
LDUR X0, [X1, #0]
ADD X1, X9, XZR
BR LR




//X1 : n
//X0 : a[]
fill:
SUBS X10, X9, X1 //X10 = i - n
B.GE exit_fill
SUB X10, X1, X9 //X10 = n - i
SUBI X10, X10, #1 //X10 = n - i - 1
//fill array a of n elements with decreasing values from n-1 to 0
LSL X11, X9, #3 //X11 = 8*i
ADD X11, X11, X0 //X11 = &a[i]
STUR X10, [X11, #0] //a[i] = n - i - 1
ADDI X9, X9, #1 //i++
PRNT X10
B fill
exit_fill:
BR LR





//X0 a[]
//X1 n
//X2 start 
//X3 value
find_index:
    
ADDI X10, X2, #0 //index = start
ADDI X9, X2, #1 //i = start + 1

find_index_loop:

SUBS X11, X9, X1 // i - n
B.GE exit_find_index

LSL X11, X9, #3 //X11 = 8*i
ADD X12, X11, X0 //X12 = &a[i]
LDUR X11, [X12, #0] //X11 = a[i]
ADDI X9, X9, #1 //i++

SUBS XZR, X11, X3 //if a[i] >= value
B.GE find_index_loop

ADDI X10, X10, #1 // index++
B find_index_loop

exit_find_index:
ADDI X0, X10, #0 //RETURN = index
BR LR



//X0 a[]
//X1 start
//X2 value
skip_duplicates:

ADDI X9, X1, #0 //i = start
skip_loop:
LSL X11, X9, #3 //X11 = 8*i
ADD X11, X10, X0 //X11 = &a[i]
LDUR X10, [X11, #0] //X10 = a[i]

SUB X12, X2, X10 //a[i] - Value
CBNZ X12, exit_skip_duplicates //if a[i]!=Value then branch
ADDI X9, X9, #1 //i++

B skip_loop

exit_skip_duplicates:
ADDI X0, X9, #0 //RETURN = i 
BR LR



//X1 : n

print_arr:
ADDI X9, X9, #0
SUBS X10, XZR, X1 //X10 = i - n
B.GE exit_fill

LSL X11, X9, #3 //X11 = 8*i
ADD X11, X11, X0 //X11 = &a[i]
LDUR X11, [X11, #0] //X11 = a[i]
ADDI X9, X9, #1 //i++

B print_arr
exit_print_arr:
ADDI X9, XZR, #0 //RESET i
BR LR

end: //LAST LINE