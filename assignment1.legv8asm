//COMS321 Programming Assignment 1
//Team member 1: Drew Hirsh - ahirsh@iastate.edu
//Team member 2: Tim Kuehn - timkuehn@iastate.edu

B main

main:

ADDI X0, XZR, #0
ADDI X1, XZR, #8
ADDI X9, XZR, #0
BL forward_fill
PRNL


ADDI X1, XZR, #0
ADDI X2, XZR, #8
ADDI X3, XZR, #4
BL binary_search
PRNT X0

B end



complete_cycle:
SUBS X9, X3, X2         //X9 = index (temp)
CBZ X9, exit_complete_cycle    //X3 = value
ADD X10, X0 XZR
ADD X9, X3, XZR
ADD X3, X4, XZR
BL find_index
ADD X11, X0, XZR
ADD X0, X10, XZR
ADD X12, X1, XZR
ADD X1, XZR, X11
ADD X13, X2, XZR
ADD X2, X3, XZR
BL skip_duplicates
ADD X14, X0, XZR


ADDI X5, X3, #0 //X5 = &value
LSL X1, X21, #3 //X1 = 8*index
ADD X1, X1, X19 //X1 = &a[index]


//swap(&value, &a[index]);
BL swap

B complete_cycle
exit_complete_cycle:
BR LR


cycle_sort:
SUB X10, X23, X20 //X10 = n - cstart
SUBIS X10, X10, #-1 //X10 (n-1) - cstart
B.GE exit_cycle_sort

//val = a[cstart]
LSL X11, X23, #3 //X11 = 8*cstart
ADD X11, X11, X19 //X11 = &a[cstart]
LDUR X24, [X11, #0] //val = a[cstart]

//set X2 to start
//set X3 to value
ADDI X2, X23, #0
ADDI X3, X24, #0

//idx = find_index(a, n, cstart, val);
BL find_index
ADDI X22, X0, #0 //idx = RETURN

SUB X10, X22, X23
CBZ X10, cycle_sort

//idx = skip_duplicates(a, idx, val);
BL skip_duplicates
ADDI X22, X0, #0 //idx = RETURN

//swap(&val, &a[idx]);
ADDI X5, X24, #0
LSL X11, X22, #3 //X11 = 8*idx
ADD X11, X22, X19 //X11 = &a[idx]

//complete_cycle(a, n, cstart, idx, val);
B complete_cycle

ADDI X23, X23, #1 //cstart++

B cycle_sort
exit_cycle_sort:
BR LR



//X0 *a
//X1 start
//X2 end
//X3 value
binary_search:
SUBS XZR, X2, X1                //X9 = END - START

B.LT return_negative_one        // END < START return 1 

ADD X9, X1, X2                 //X10 = START + END
LSR X9, X9, #1                 //INDEX = (START+END)/2 

LSL X10, X9, #3                 //X10 = 8*index
ADD X10, X10, X0                //X10 = &a[index]
LDUR X10, [X10, #0]             //X11 = a[index]

SUBS X11, X10, X3               //X11 = a[index] - value
CBZ X11, return_index           //if a[index]==value exit return index

SUBI SP, SP, #8
STUR LR, [SP, #0]

B.GT recursive_call             //binary_search(a, start, index -1, value)

ADDI X1, X9, #1                 //start = index +1

BL binary_search

LDUR LR, [SP, #0]
ADDI SP, SP, #8


BR LR

return_negative_one:
ADDI X0, XZR, #-1               //returns -1
BR LR

return_index:
PRNT x1
PRNT X2
ADD X0, XZR, X9

BR LR

recursive_call:
SUBI X2, X9, #1                 //end = index - 1

BL binary_search                //binary_search(a, index+1, end, value)

LDUR LR, [SP, #0]
ADDI SP, SP, #8

BR LR


swap:
LDUR X9, [X0, #0]
LDUR X0, [X1, #0]
ADD X1, X9, XZR

BR LR

//X1 : n
//X0 : a[]
fill:

SUBS X10, X9, X1 //X10 = i - n
B.GE exit_fill


SUB X10, X1, X9 //X10 = n - i
SUBI X10, X10, #1 //X10 = n - i - 1

//fill array a of n elements with decreasing values from n-1 to 0
LSL X11, X9, #3 //X11 = 8*i
ADD X11, X11, X0 //X11 = &a[i]


STUR X10, [X11, #0] //a[i] = n - i - 1
ADDI X9, X9, #1 //i++
PRNT X10
B fill

exit_fill:

BR LR


//X0 :a[]
//X1: n
forward_fill:
SUBS X10, X9, X1 //X10 = i - n
B.GE exit_forward_fill

ADD X10, XZR, X9

//fill array a of n elements with decreasing values from n-1 to 0
LSL X11, X9, #3 //X11 = 8*i

ADD X11, X11, X0 //X11 = &a[i]
STUR X10, [X11, #0]

PRNT X10

ADDI X9, X9, #1 //i++

B forward_fill
exit_forward_fill:
BR LR




//X0 a[]
//X1 n
//X2 start 
//X3 value
find_index:
ADDI X9, X2, #1 //i = start + 1
ADDI X10, X2, #0 //index = start

find_index_loop:
SUBS XZR, X9, X1 // i - n
B.GE exit_find_index

LSL X11, X9, #3 //X11 = 8*i
ADD X12, X11, X0 //X11 = &a[i]
LDUR X11, [X12, #0] //X11 = a[i]

ADDI X9, X9, #1 //i++

SUBS XZR, X3, X11 //X10 = a[i] - Value
B.GE find_index_loop

ADDI X10, X10, #1 // index++

B find_index_loop

exit_find_index:
ADDI X0, X10, #0 //RETURN = index
BR LR

//X0 a[]
//X1 start
//X2 value
skip_duplicates:

ADDI X9, X1, #0 //i = start
skip_loop:
LSL X11, X9, #3 //X11 = 8*i
ADD X11, X10, X0 //X11 = &a[i]
LDUR X10, [X11, #0] //X10 = a[i]

SUB X12, X2, X10 //a[i] - Value
CBNZ X10, exit_skip_duplicates //if a[i]!=Value then branch

ADDI X9, X9, #1 //i++

B skip_loop

exit_skip_duplicates:
ADDI X0, X9, #0 //RETURN = i 
BR LR

//X1 : n

print_arr:
ADDI X9, X9, #0
SUBS X10, XZR, X1 //X10 = i - n
B.GE exit_fill

LSL X11, X9, #3 //X11 = 8*i
ADD X11, X11, X0 //X11 = &a[i]
LDUR X11, [X11, #0] //X11 = a[i]

PRNT X11

ADDI X9, X9, #1 //i++

B print_arr
exit_print_arr:
ADDI X9, XZR, #0 //RESET i
BR LR

end: //LAST LINE