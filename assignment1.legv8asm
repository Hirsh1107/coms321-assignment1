//COMS321 Programming Assignment 1
//Team member 1: Drew Hirsh - ahirsh@iastate.edu
//Team member 2: Tim Kuehn - timkuehn@iastate.edu

B main

main:
ADDI X0, XZR, #5 //swap param i
ADDI X1, XZR, #12 //swap param j
ADDI X2, XZR, #0 //TEMP START
ADDI X3, XZR, #3 //TEMP VALUE
ADDI X4, XZR, #8 //TEMP END
ADDI X5, XZR, #0 //RETURN
ADDI X9, XZR, #0 //TEMP i for loops
ADDI X10, XZR, #0 //TEMP COMPARE for loops
ADDI X11, XZR, #0 //TEMP VALUE for loops
ADDI X19, XZR, #0 //array A
ADDI X20, XZR, #12 //length of array n
ADDI X21, XZR, #0 //INDEX
ADDI X22, XZR, #0 //IDX
ADDI X23, XZR, #0 //CSTART
ADDI X24, XZR, #0 //VAL

BL fill
BL print_arr
BL cycle_sort

B end


complete_cycle:

SUB X10, X21, X2 //X10 = index - start
CBZ X10, exit_cycle //if start=index exit

BL find_index //find_index()
BL skip_duplicates //skip_duplicates

ADDI X0, X3, #0 //X0 = &value
LSL X1, X21, #3 //X1 = 8*index
ADD X1, X1, X19 //X1 = &a[index]

PRNT X0
PRNT X1

//swap(&value, &a[index]);
BL swap

B complete_cycle
exit_cycle:
BR LR


cycle_sort:
SUB X10, X23, X20 //X10 = n - cstart
SUBIS X10, X10, #-1 //X10 (n-1) - cstart
B.GE exit_cycle_sort

//val = a[cstart]
LSL X11, X23, #3 //X11 = 8*cstart
ADD X11, X11, X19 //X11 = &a[cstart]
LDUR X24, [X11, #0] //val = a[cstart]

//set X2 to start
//set X3 to value
ADDI X2, X23, #0
ADDI X3, X24, #0
PRNT X2
PRNT X3

//idx = find_index(a, n, cstart, val);
BL find_index
ADDI X22, X5, #0 //idx = RETURN

SUB X10, X22, X23
CBZ X10, cycle_sort

//idx = skip_duplicates(a, idx, val);
BL skip_duplicates
ADDI X22, X5, #0 //idx = RETURN

//swap(&val, &a[idx]);
ADDI X0, X24, #0
LSL X11, X22, #3 //X11 = 8*idx
ADD X11, X22, X19 //X11 = &a[idx]

//complete_cycle(a, n, cstart, idx, val);
B complete_cycle

ADDI X23, X23, #1 //cstart++

B cycle_sort
exit_cycle_sort:
BR LR


binary_search:

//TODO implement binary_search

BR LR

swap:
SUBI SP, SP, #16 //ALLOCATE MEMORY TO SP

PRNT X0
PRNT X1

STUR X0, [SP, #0]
STUR X1, [SP, #8]

LDUR X0, [SP, #8]
LDUR X1, [SP, #0]

PRNT X0
PRNT X1

ADDI SP, SP, #16 //RESTORE SP
BR LR


fill:
SUBS X10, X9, X20 //X10 = i - n
B.GE exit_fill

//fill array a of n elements with decreasing values from n-1 to 0
LSL X11, X9, #3 //X11 = 8*i
ADD X11, X11, X19 //X11 = &a[i]

SUB X10, X20, X9 //X10 = n - i
SUBI X10, X10, #1 //X10 = n - i - 1

STUR X10, [X11, #0] //a[i] = n - i - 1

ADDI X9, X9, #1 //i++

B fill
exit_fill:
ADDI X9, XZR, #0 //RESET i
BR LR


find_index:
SUBS X10, X9, X20 //X10 = i - n
B.GE exit_find_index

LSL X11, X9, #3 //X11 = 8*i
ADD X11, X11, X19 //X11 = &a[i]
LDUR X11, [X11, #0] //X11 = a[i]

ADDI X9, X9, #1 //i++

SUBS X10, X3, X11 //X10 = VALUE - a[i]
B.GE exit_find_index

ADDI X21, X21, #1 //index++

B find_index
exit_find_index:
ADDI X5, X21, #0 //RETURN = index
ADDI X21, XZR, #0 //RESET index
BR LR


skip_duplicates:
SUBS X10, X9, X20 //X10 = i - n
B.GE exit_skip_duplicates

LSL X11, X9, #3 //X11 = 8*i
ADD X11, X11, X19 //X11 = &a[i]
LDUR X11, [X11, #0] //X11 = a[i]

SUB X10, X11, X3 //VALUE
CBZ X10, exit_skip_duplicates

ADDI X9, X9, #1 //i++

B skip_duplicates
exit_skip_duplicates:
ADDI X5, X9, #0 //RETURN = i 
ADDI X9, XZR, #0 //RESET i
BR LR


print_arr:
SUBS X10, X9, X20 //X10 = i - n
B.GE exit_fill

LSL X11, X9, #3 //X11 = 8*i
ADD X11, X11, X19 //X11 = &a[i]
LDUR X11, [X11, #0] //X11 = a[i]

PRNT X11

ADDI X9, X9, #1 //i++

B print_arr
exit_print_arr:
ADDI X9, XZR, #0 //RESET i
BR LR

end: //LAST LINE



